# ReplicaSet(= 레플리카셋) 개념과 특징

레플리카셋은 파드 복제본을 생성하고 관리함.

* N개의 파드를 생성하기 위해 생성 명령을 N번 실행할 필요가 없음.
* 레플리카셋 오브젝트를 정의하고 원하는 Pod의 개수를 replicas 속성으로 선언.
* 클러스터 관리자 대신 파드 수가 부족하거나 넘치지 않게 파드 수를 조정.

# 왜 레플리카셋이 필요한가?

## 파드에 문제가 생겼다면...

파드는 즉시 종료되고 클라이언트 요청을 처리할 수 없음. Availability 확보 불가.  
쿠버네티스 클러스터 관리자가 항상 파드 상태를 감시하고 정상 복구해야 함 → 사실상 불가능
따라서 자동으로 N개의 파드를 필요 시 재시작하고 상태 이상에 대비해야 하는 수요가 있음.

"SW가 내결함성을 가짐" - fault tolerance

* 어떤 실패가 발생하더라도 SW는 동일한 기능을 수행할 수 있어야 함.
* SW가 내결함성이 없으면 고객 요구 사항을 만족시킬 수 없음.

## 레플리카셋이 이를 해결하는 방법

파드 혹은 노드 상태에 따라 파드의 수를 조정할 수 있도록 레플리카셋에게 역할을 위임.

* 레플리카셋 오브젝트를 이용해 파드 복제 / 복구 작업을 자동화.
* 쿠버네티스 클러스터 관리자는 레플리카셋 오브젝트를 만들어 필요한 파드의 수를 쿠버네티스에게 선언.
* 쿠버네티스는 레플리카셋 오브젝트의 요청서에 선언된 replicas 정보를 읽고 그 수 만큼 파드 실행을 보장.

# 레플리카셋 오브젝트 표현 방법

## 레플리카셋 오브젝트 yaml 규칙

```
apiVersion: apps/v1 # Kubernetes API 버전

kind: ReplicaSet # 오브젝트 타입

metadata: # 오브젝트를 유일하게 식별하기 위한 정보
  name: blue-app-rs # 오브젝트 이름
  labels: # 오브젝트 집합을 구할때 사용할 이름표, key-value 형태
    app: blue-app

spec: # 사용자가 원하는 파드의 바람직한 상태
  selector: # 레플리카셋이 관리해야 하는 파드를 선택하기 위한 label query
  replicas: # 실행할 파드 복제본 숫자 선언
  template: # Pod 실행 정보, Pod Template과동일(metadata, spec, …)
```

## 셀렉터 관련 규칙

```
spec:
  selector: # 레플리카셋이 관리할 파드 집합 선택
    matchLabels:
      app: blue-app # Pod label query 작성
  replicas: 3 # 유지할 파드 복제본 수
```

## 템플릿 관련 규칙

```
spec:
  selector:
    matchLabels:
      app: blue-app
  replicas: 3

  # 파드 템플릿 정의 여기서부터 시작, 파드 yaml 문법과 동일(단, appVersion이나 kind는 레플리카셋으로부터 가져와서 필요 없음)
  template: 
    metadata:
      labels:
        app: blue-app # 레플리카셋 셀렉터에서 정의한 레이블 포함 필수
    spec:
      containers:
      - name: blue-app
        image: blue-app:1.0
```

# 레플리카셋 주의할 점 & Tips

## 레플리카셋은 로드 밸런싱을 담당하지 않음!

포트 포워딩으로 호스트의 포트랑 레플리카셋 오브젝트의 포트랑 연결해도 항상 하나의 파드랑만 연결될 것.

## 레플리카셋 업데이트?

yaml 수정 후 `kubectl apply` 커맨드 다시 실행

## 실행 중인 파드의 수를 쉽게 늘리고 줄이기 가능

Up, Down이라 칭함.
레플리카셋에 선언한 replicas 값을 변경.  
레플리카셋이 현재 실행 중인 파드 수와 클러스터 관리자가 선언한 replicas 수를 비교해서 파드 숫자를 조정.

## 기존에 만들어둔 파드들도 나중에 만든 레플리카셋으로 관리가 가능

단, 기존에 있던 친구가 레플리카셋의 셀렉터 조건에 맞아야 함.  
레플리카셋을 생성할 때 셀렉터 조건에 맞는 파드가 이미 있다면 그거 빼고 나머지 숫자만 만듬.  
꼭 레플리카셋 생성 시 만들어진 친구들만 관리 대상인건 아님!!  

## 그럼 레이블이 다르던 파드를 관리하고 싶다면?

1. 기존 레플리카셋 삭제
2. 관리하고 싶은 파드에 관리할 파드들과 같은 레이블 추가
3. 추가한 레이블을 관리하는 새 레플리카셋 배포

## 배포한 레플리카셋의 파드 템플릿을 변경해도, 기존 파드에는 영향이 없음

레플리카셋에 선언한 replicas 수치가 변경되었을 경우에만 파드를 새로 생성하거나 제거함.  
대신, 어떤 파드가 죽었거나 해서 다시 켜지게 된다면 새로운 파드 템플릿 규칙에 따라 만들어지게 됨.  
따라서 일부러 끄지 않는 한, 구버전 템플릿 형태의 파드와 신버전 템플릿 형태의 파트가 공존함.

# 레플리카셋 롤백 전략

## 레플리카셋의 파드 템플릿 이미지 변경으로 롤백

실행 중인 파드 장애 시 레플리카셋을 새로 생성하지 않고 이전 버전의 파드 배포가 가능.  

1. 레플리카셋 파드 템플릿의 이미지를 이전 버전으로 변경하고 적용.
2. 기존 파드 모두 제거. (replica 수치 0)
3. replica 수치 원복 적용.
4. 이전 버전의 이미지 베이스 파드들이 자동 배포.

혹은...

1. 레플리카셋 파드 템플릿의 이미지를 이전 버전으로 변경하고 적용.
2. 기존 파드의 레이블을 레플리카셋 셀렉터 조건과 다르게 일괄 변경.
3. 이전 버전의 이미지 베이스 파드들이 자동 배포.
4. 남아있는 문제 버전들 가지고 디버깅 진행 가능.

# 레플리카셋 포인트

* 레플리카셋으로 파드 복제본(replicas)를 생성 & 관리.
    * 여러 노드에 걸쳐 배포된 파드의 Up/Down 상태를 감시하고 replicas 수 만큼 실행을 보장.
* 레플리카셋의 spec.selector.matchLabels 속성은 파드 템플릿의
spec.template.metadata.labels와 같아야 함.
* spec.replicas를 선언하지 않으면 기본값은 1.

# 레플리카셋 관련 명령어

* 레플리카셋 생성  
`$ kubectl apply -f <yaml 파일 경로>`
* 레플리카셋과 배포 이미지 확인  
`$ kubectl get rs <replicaset-name> -o wide`

* 레플리카셋의 이벤트 기록(파드 생성) 확인  
`$ kubectl describe rs <replicaset-name>`
* 레플리카셋의 파드 생성 이후 과정 확인  
`$ kubectl get events --sortby=.metadata.creationTimestamp`
* 레플리카셋 파드로 트래픽 전달  
`$ kubectl port-forward rs/<replicaset-name> 8080:8080`

* 레플리카셋 replicas 수 변경
`$ kubectl scale rs/<replicaset-name> --replicas <number of replicas>`

* 레플리카셋 삭제(산하 파드도 같이 삭제)  
`$ kubectl delete rs blue-replicaset`
* 레플리카셋 삭제(산하 파드 살려둠)  
`$ kubectl delete rs blue-replicaset --cascade=orphan`
* 레플리카셋 삭제(graceful)  
`$ kubectl scale rs blue-replicaset --replicas 0`  
`$ kubectl delete rs blue-replicaset`